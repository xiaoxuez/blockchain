## 共识整理



整体分析各共识算法，以及各大提高吞吐量和交易速度(以下统称可扩展性)所采取的方式。



基本共识算法

+ BFT，缺点是随着节点数增加，可扩展性明显下降。当节点小于100，能达到1000tps
+ POW，缺点是出块速度慢，明显交易量不能太大，如比特币
+ POS，代表链为量子链（量子链吞吐量似乎没有很高，就在几百之间）
+ DPOS，代表链为EOS



增加扩展性手段

+ 侧链
+ 分片
+ DAG




区块链增加扩展性实例

+ 闪电网络： 侧链。链下多笔交易，最后一笔且包含余额动态的交易上传回链（通俗的说就是减少链上交易）
+ EOS：DPOS+BFT， 看文档说是EOS也有分片的概念，但只有概念，没有再详细的解锁了，也没有宣传，估计还在计划期。目前tps为6000左右
+ Zilliqa：分片+BFT。tps为1000+。



BFT的缺点是节点数增多的情况下，会降低吞吐量，但加入分片的选择，就能将节点数保持在比较好的情况，分片在一定层次上意味着并行处理，即将节点分成几个共识组，交易按一定规则分配到某一组，各组之间共识出块可并行，所以Zilliqa节点增多的情况下，tps基本不会受太大影响，相反可能还会更好。

EOS优化的选择加入BFT，出块后立马广播进行区块验证确认，而不用等到自己出块的时候再验证。减小了区块验证的时间。也为将区块生成的时间改为0.5s做保障

EOS虽然官方说tps有6000，但毕竟项目还没落地上线…相对来说，Zilliqa的tps就靠谱很多。

目前看起来增加吞吐量的手段，大概都是以上共识和增加扩展的组合或选择。



#### 更多的共识算法

#### pow     工作量证明

优点：1)算法简单，容易实现；2)节点间无需交换额外的信息即可达成共识；3)破坏系统需要投入极大的成本；
缺点：1)浪费能源；2)区块的确认时间难以缩短；3)新的区块链必须找到一种不同的散列算法，否则就会面临比特币的算力攻击；4)容易产生分叉，需要等待多个确认；5)永远没有最终性，需要检查点机制来弥补最终性；



**链：BTC、LTC**

#### pos     权益证明

优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源挖矿。
缺点：还是需要挖矿，本质上没有解决商业应用的痛点；所有的确认都只是一个概率上的表达，而不是一个确定性的事情，理论上有可能存在其他攻击影响。

通俗的说，PoS 就是**资本主义，按钱分配，钱生钱。**

**链：量子链、恒星币，狗狗币等**，



#### dpos    委任权益证明

优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。
缺点：整个共识机制还是依赖于代币，很多商业应用是不需要代币存在的。



#### pbft        实用拜占庭容错

优点：1）系统运转可以脱离币的存在，pbft算法共识各节点由业务的参与方或者监管方组成，安全性与稳定性由业务相关方保证。2）共识的时延大约在2~5秒钟，基本达到商用实时处理的要求。3）共识效率高，可满足高频交易量的需求。
缺点：1)当有1/3或以上记账人停止工作后，系统将无法提供服务；2)当有1/3或以上记账人联合作恶，且其它所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但是会留下密码学证据



#### dBFT        授权拜占庭容错算法

优点：1)专业化的记账人；2)可以容忍任何类型的错误；3)记账由多人协同完成，每一个区块都有最终性，不会分叉；4)算法的可靠性有严格的数学证明；
缺点：1)当有1/3或以上记账人停止工作后，系统将无法提供服务；2)当有1/3或以上记账人联合作恶，且其它所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但是会留下密码学证据；

**链: NEO**

在NEO的共识算法中，共识节点由NEO持有人股票选出，并对区块链中交易的有效性进行验证。

DBFT的算法大致原理是这样。参与记账的是超级节点，普通节点可以看到共识过程，并同步账本信息，但不参与记账。总共n个超级节点分为一个议长和n-1个议员，议长会轮流当选。每次记账时，先有议长发起区块提案（拟记账的区块内容），一旦有至少（2n+1)/3个记账节点（议长加议员）同意了这个提案，那么这个提案就成为最终发布的区块，并且该区块是不可逆的，所有里面的交易都是百分之百确认的。



#### PoB：Proof of Believability，可信度证明机制。

该共识机制对节点持有的资金和声誉均有一定的要求，只有符合的要求的节点才能取得一定的地位。

可信度证明共识协议使用分片间可信度优先（Believable-First）方法。该协议将所有验证者分为两组，一个高可信分组和一个普通分组。高可信验证人在第一阶段快速处理交易。之后，在第二阶段，普通验证人对这些交易进行抽样和验证，以提供最终结果并确保可验证性。节点被选入高可信分组的机会由可信度得分确定，可信度得分由多个因素计算得到，例如：代币余额、对社区的贡献度、网络行为等。

**链： IOST**

该协议将所有验证者分为两组，一个高可信分组和一个普通分组。高可信验证人在第一阶段快速处理交易。之后，在第二阶段，普通验证人对这些交易进行抽样和验证，以提供最终结果并确保可验证性。节点被选入高可信分组的机会由可信度得分确定，**可信度得分由多个因素计算得到，例如：代币余额、对社区的贡献度、网络行为等**

IOST共识算法采用POB，可信度证明机制。白皮书中提到**可信度得分由多个因素计算得到，例如：代币余额、对社区的贡献度、网络行为等**。

- 节点启动时需绑定账户

- 评分结构体

  ```
  type Servi struct {
  	v     float64 // behavior  -- 行为分
  	b     float64 // balance -- 余额
  	owner vm.IOSTAccount 
  }
  //总分为二者相加
  func (s *Servi) Total() float64 {
  	return s.b + s.v
  }
  ```

  余额即是账户余额，behavior的更新规则为，behavior与节点发起的交易数量成线性关系。

  ```
  type Tx struct {
  	Time      int64
  	Nonce     int64
  	Contract  vm.Contract
  	Signs     []common.Signature
  	Publisher common.Signature
  	Recorder  common.Signature  // <-交易由某节点开始发起传达给网络，该节点会进行签名
  }

  //接收到新的已被上链的区块，会调用AddServi方法，更新行为分
  func (h *Holder) AddServi(tx []Tx) {
       for _, t := range tx {
  		if len(t.Recorder.Pubkey) == 0 {
  			continue
  		}
  		//将更新其交易发起节点servi的Behavior分数
  		servi, err := h.Spool.User(vm.PubkeyToIOSTAccount(t.Recorder.Pubkey))
  		if err != nil {
  			servi.IncrBehavior(1)
  			...
  	  ...
  	  }
  }
  ```

​       

结论，IOST目前仍在开发中，代码可能不全，但从目前代码来看，评分值是跟账本一样，量化在数据库中，根据区块交易行为来对评分进行更新。



#### PoC：Proof of Credit，信用证明机制。

在该共识机制中，只要节点信用达标，其锁定一定保证金即可加入共识。共识节点重新排序后每轮轮流出块，退出共识时保证金解锁。

需要注意的是，PoC大多时候用于指代“概念证明（Proof of Concept）”。

**链： NULS**

在 NULS 系统里，信用是账户在系统中的诚信系数，所有账户的信用会在区间[-1,1]内，通过信用评级算法公式自动计算。

信用评估公式：

信用基数=能力系数+责任系数

能力系数：根据历史出块数量计算

责任系数：根据违规情况和出块正确性计算



#### poi        账户重要度证明Proof of Importance

POI共识算法其实可以看做是POS算法的一个变种，只不过是POI共识算法是对账户的重要性做评分，根据评分的高低来分配记账权，与POS根据权益的大小来分配记账权类似。
优点：1、能源消耗少，效率高，速度快。
缺点：1、缺乏社区共识

**NEM链**

**余额、账户活跃度以及与其交互的账户的活跃度为考量因素生成重要性分数**，随着用户重要性得分越来越高，他们获得记账奖励的机会就越大。更高的信用分数，意味着网络更信任你，会让你验证更多的交易，获取更多的交易费。也就是说，赢得更多的记账机会。





#### PoA     行动证明Proof of activity

PoA是一种PoW和PoS的混合方式。
在PoA中，首先以一种传统的PoW方式开始挖矿，矿工相互竞争来解决密码谜团。根据这种实施，挖出的区块不包含任何的交易（它们更像模板），所以赢得的区块将会仅仅包括一个header和该矿工的奖励地址。

这时候，系统将会切换到PoS。基于这个header的信息，一组随机的validators被挑选出来对这个新的区块进行签名。手中持有币越多的validator被选中的概率就越高。一旦这些被选中的validator全部完成对该区块的签名，该模板就成为了一个完整的区块。

如果一些被选中的validator不可用于对该区块进行签名，那么将会被选中对下一个区块进行签名，然后再选出新一组的validators等等，直到区块获得正确数量的签名。手续费将会被分配给矿工和参与区块签名的validator。

PoA遭受了与PoW（挖矿需要的计算能源太多）和POS（无法阻止Validator重复签名）一样的批评。



**Decred是目前唯一使用PoA变化形式的加密货币**

在Decred的技术文档中，对POA的解释如下

> The validation of PoW blocks is explained by the following steps:
>
> 1. A block is mined by a PoW miner, who selects the transactions to put inside it. Stake system related transactions are inserted into the UTXO set.
> 2. PoS miners vote on the block by producing a vote transaction from their ticket. The vote both enables a block to be built on top of the previous block and selects whether or not the previous regular transaction tree (containing the coinbase and non-stake related transactions) is valid.
> 3. Another PoW miner begins building a block, inserting the PoS miners’ votes. A majority of the votes cast must be included in the following block for that block to be accepted by the network. Of the vote transactions in this new block, the PoW miner checks a flag to see if the PoS miner indicated if the block’s regular transaction tree was valid. These voting flags are tallied and, based on majority vote, a bit flag is set in this block to indicate if the previous block’s regular transaction tree is valid.
> 4. A nonce is found that satisfies the network difficulty, and the block is inserted into the blockchain. If the previous block’s regular transaction tree was validated, insert these transactions into the UTXO set. Go to 1.

而Decred使用的是Blake256算法，需要显卡的硬计算能力，该算法在x86-64架构上面有着更好的性能表现，而且安全性要更高。

在POS机制方面，Decred上的POS协议使得用户可以通过持票（ticket）来为Decred的某项改进提案（DCP，类似于比特币里面的BIP与以太坊里面的EIP）进行投票，比如开发团队是否需要在某项新功能的开发上投入时间，是否要激活某项功能，如何使用经费等等。

为了参与POS，用户需要锁定自己的一部分DCR代币来换取ticket，每张ticket可以进行一次投票，投票完成之后，用户解锁相应的DCR代币并能够获得一定的奖励，这个过程我们称之为POS挖矿。每张ticket会被随机的选举以参加投票，平均时间大约是28天，但最高可能会达到142天，并有0.5%的机票选票被作废。

POW矿工生成每个区块的时候最少应有5张选票来进行确认，如果少于5张时POW矿工的奖励会减少以示惩罚，同时最多可以有20张选票。POS的难度调整算法将每隔144个区块调整一次ticket的价格，使得维持票池里的票数在40960左右。用户参与POS挖矿需要支付选票费给POW矿工，以便POW矿工将自己的ticket打包放入新挖的区块之中。当ticket被选中进行投票的时候，用户的钱包应当在线以行使自己的投票权，如果无法投票，则用户不能获得奖励，为了方便无法保持全天在线的用户，用户可以选择POS矿池代为投票，并向POS矿池支付一定的费用。

如下是我们从Decred钱包截取的关于Ticket的页面设置图，用户可以直接购买ticket并委托给矿池进行管理，同时ticket经过打包之后便成为活跃的（live）状态可以参与投票。而随着参与POS挖矿的用户越来越多，被锁定的DCR代币也越来越多，因此流通的DCR就会相应的减少，而提升DCR代币的价值



#### POP        账户参与度证明Proof of Participation

POP共识算法其实就是将上面讲到的POI共识算法和DPOS共识算法相结合所产生的一种新的共识算法，他具有POI算法的公平、安全、效率高的优点，同时又解决了缺乏社区共识的问题。它是标准链（CZR）的创新产物。
优点：1、能源消耗少、速度快，安全性高，2、这种共识算法既能确保对设备的公平性，又拥有社区的共识。
缺点：1、作为一个新生的共识算法，其并没有得到规模化和长时间的实际验证，与POW长达10多年的稳定运行相比，POP的共识算法还有待实践检验。

**链：canonchain(标准链)**

在PoP共识机制中,系统将首先选取生态中广泛的具有代表性的账户作为 候选账户。选择候选账户时,系统同时考虑多种因素:如,账户的地域分布; 账户的业务类型;和此账户关联的设备贡献度。候选账户是具有广泛的代表性, 这个方法非常接近于人民代表大会制度,每个人民代表具有相同的投票权力, 而他们又是各自的省份和各自行业中的佼佼者。

社区对系统生成的候选账户进行投票,按照所得票数的多少,系统从中按照概率挑选总N个账户作为区块生成者,其中N由社区投票决定,并被写入到标准链玄规中，候选账户所获得的投票数越多,被选中成为区块生成者的机会就越大。因此最终所选取的区块生成者既具有了广泛的代表性,又拥有社区的共识。通过社区投票可以剔除那些虽然具有设备贡献力,但是却对社区建设不够活跃的或者恶意破坏标准链生态的账户。





#### Tangle共识      DAG

一个网络节点要发起一笔新的交易时，需要在Tangle中找2笔合法的历史交易（IOTA官方推荐采用马尔可夫蒙特卡洛（MCMC）随机游走的方法），并且将自己新发起的交易指向这两笔交易。通过这种方式，整个Tangle网络不断向右扩展开来。

基于这样的设计，IOTA中每笔交易通过指向2笔历史交易，直接验证了这两笔历史交易，并且间接验证了这两笔历史交易直接和间接指向的更早的交易。

Tangle中的交易分为3类别，一类是已经达成共识的交易，另一类是还没有达成共识的交易，最后一类是末梢交易（tips）。



----



### 应用

#### Filecoin涉及到的证明概念

- **数据持有性证明（Provable Data Possession ，PDP)**：用户发送数据给矿工进行存储，矿工证明数据已经被自己存储，用户可以重复检查矿工是否还在存储自己的数据
- **可检索证明（Proof-of-Retrievability，PoRet）**：和PDP过程比较类似，证明矿工存储的数据是可以用来查询的。
- **存储证明（Proof-of-Storage ，PoS）**：利用存储空间进行的证明。工作量证明的一种，Filecoin上一篇论文使用了这个名字，新的论文则升级为PoRep
- **复制证明（Proof-of-Replication，PoRep）**：新的 PoS（Proof-of-Storage），PoRep可以保证每份数据的存储都是独立的，可以防止女巫攻击，外源攻击和生成攻击
- **工作量证明（Proof-of-Work，PoW）**：证明者向检验者证明自己花费了一定的资源，PoW被用在加密货币，拜占庭共识和其他各种区块链系统。BTC使用的就是这种类型的证明，依赖巨量的哈希计算和能源消耗来建立共识和保证btc网络的安全性
- **空间证明（Proof-of-Space，PoSpace）**：Filecoin提出的概念，存储量的证明，PoSpace是PoW的一种，不同的是PoW使用的计算资源，而PoSpace使用的是存储资源
- **时空证明（Proof-of-Spacetime，PoSt)**：时空证明，矿工证明自己花费了spacetime资源, 即：一定时间内的存储空间的使用，PoSt是基于PoReps实现的
- **复制证明（Proof of Replication，PoRep）**：PoRep 是PoS的进化版：用来证明 数据（data）已经被矿工存储

#### NEO

改进的BFT — DBFT，授权拜占庭容错，是基于持有权益比例来选出专门的记账人（记账节点），然后记账人之间通过拜占庭容错算法（即少数服从多数的投票机制）来达成共识，决定动态参与节点。dBFT可以容忍任何类型的错误，且专门的多个记账人使得每一个区块都有最终性、不会分叉。



#### NULS

PoC（Proof-Of-Credit)信用共识机制，末尾有详解。



#### IOST

POB（Proof-of-Believebility consensus approach）可信度证明

可信度证明共识协议使用分片间可信度优先（Believable-First）方法。该协议将所有验证者分为两组，一个高可信分组和一个普通分组。高可信验证人在第一阶段快速处理交易。之后，在第二阶段，普通验证人对这些交易进行抽样和验证，以提供最终结果并确保可验证性。节点被选入高可信分组的机会由可信度得分确定，可信度得分由多个因素计算得到，例如：代币余额、对社区的贡献度、网络行为等。



#### 共识机制——POC

NULS 的模块化设计，支持共识机制在内的所有核心功能模块的替换与插拔。NULS 主链默认采用信用共识机制 POC(Proof-Of-Credit)。节点信用达标的情况下，锁定一定保证金即可加入共识，共识节点重新排序后每轮轮流出块，退出共识时保证金解锁。

#### 1、共识进入与退出机制

任何人都可以随时加入 NULS 的共识之中，只要满足条件，遵守规则，即可持续获得 NULS 代币奖励。POC 的加入分为硬性指标和软性指标。硬性指标指的是信用分值必须达到一定标准线，排除掉一部分曾经作恶的节点。软性指标指的是必须冻结一定量的 NULS 代币作为保证金，为杜绝节点的泛滥，同时让整个系统更加公平，保证金的数量除了有一个最低值的限制外，任何人可自由选择保证金的数量，保证金的数量会和最终的奖励挂钩。

##### 1.1黄牌警告

由于节点硬件配置或者网络原因，造成的共识期间掉线、死机等无法出块的，不属于违规情况，但对整个系统会造成一定影响，所以对这类情况，系统有一个轻度的警告机制：冻结保证金 72 小时，且会影响信用的评定。

##### 1.2红牌警告

对于一些双花、尝试分叉系统、不遵守系统规则的恶意人为破坏情况，NULS系统坚决抵制，所有节点都可以检测到这类情况的发生；一旦有恶意节点确实试图挑战系统，那么对应的保证金将会被锁定 1 个月，且再次信用评级，将永远达不到共识门槛。

#### 2、信用评级

在 NULS 系统里，信用是账户在系统中的诚信系数，所有账户的信用会在区间[-1,1]内，通过信用评级算法公式自动计算。

信用评估公式：

信用基数=能力系数+责任系数

能力系数：根据历史出块数量计算

责任系数：根据违规情况和出块正确性计算

#### 3、共识奖励

为了整个 NULS 系统的平衡与公平，共识奖励根据所有共识节点所提交保证金与共识节点信用综合计算。

共识奖励计算公式：

$$ coinbase = fee + 5000000 \times rnc \times \frac{bti}{spy} \times \frac{cmc \times max(0,cr)}{\sum_1^{rnc}cmc \times max(0,cr)} $$

- fee：本块手续费
- rnc：本轮共识节点数
- bti：出块间隔时间（秒）
- spy：一年总时间（秒）
- cmc：共识抵押代币数
- cr：信用基数



